# smartPager/server/modules/summary_generator.py
"""
Natural language summary generation for schedules.

Provides:
- Single day schedule summaries
- Week overview summaries  
- Changes/modifications summaries (for TTS feedback)
- ESP32-friendly agenda format
"""

import os
from datetime import datetime
from openai import OpenAI
from typing import Optional, Dict, Any, List

from .schedule_manager import DAYS_OF_WEEK


def get_openai_client() -> OpenAI:
    """Get OpenAI client with API key from environment"""
    api_key = os.getenv("OPENAI_API_KEY")
    if not api_key:
        raise RuntimeError("OPENAI_API_KEY not set in environment variables.")
    return OpenAI(api_key=api_key)


def generate_summary_text(schedule: dict) -> str:
    """
    Takes a schedule dictionary produced by scheduler.py and returns
    a natural-language summary (string) generated by ChatGPT.
    
    Args:
        schedule: Dictionary with 'events' list from scheduler
        
    Returns:
        Human-readable summary of the schedule
    """
    # Extract events list
    events = schedule.get("events", [])
    
    if not events:
        return "You have no scheduled events for today."

    # Convert ISO strings to datetime objects and sort chronologically
    formatted_items = []
    for event in events:
        name = event["name"]
        ev_type = event.get("type", "event")

        try:
            start_dt = datetime.fromisoformat(event["start"])
            end_dt = datetime.fromisoformat(event["end"])

            start_human = start_dt.strftime("%H:%M")
            end_human = end_dt.strftime("%H:%M")

            formatted_items.append(
                f"{start_human}–{end_human} — {name} ({ev_type})"
            )
        except (KeyError, ValueError) as e:
            print(f"[summary_generator] Skipping malformed event: {event}, error: {e}")
            continue

    formatted_items.sort()
    schedule_block = "\n".join(formatted_items)

    system_prompt = (
        "You are a concise, friendly personal assistant. "
        "Your job is to summarize the user's daily schedule clearly and naturally. "
        "Do not add tasks. Do not modify times. Do not guess missing information. "
        "Convert 24-hour times to natural 12-hour phrases (like '10am', '4pm', '7pm'). "
        "Keep it brief - 2-3 sentences maximum. This will be spoken aloud."
    )

    user_prompt = (
        "Here is the user's schedule for today:\n\n"
        f"{schedule_block}\n\n"
        "Please summarize this schedule in natural language."
    )

    try:
        client = get_openai_client()
        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ]
        )

        summary_text = response.choices[0].message.content.strip()
        print(f"[summary_generator] Generated summary: '{summary_text[:100]}...'")
        return summary_text

    except Exception as e:
        print(f"[summary_generator] Error generating summary: {e}")
        return "Could not generate summary due to an internal error."


def generate_agenda_for_esp32(schedule: dict) -> dict:
    """
    Generate a simplified agenda format suitable for ESP32 display.
    
    Args:
        schedule: Dictionary with 'events' list from scheduler
        
    Returns:
        Dictionary with 'next_item' and 'today' fields for ESP32
    """
    events = schedule.get("events", [])
    
    if not events:
        return {
            "next_item": None,
            "today": []
        }
    
    now = datetime.now()
    today_items = []
    next_item = None
    
    for event in events:
        try:
            start_dt = datetime.fromisoformat(event["start"])
            end_dt = datetime.fromisoformat(event["end"])
            
            item = {
                "title": event["name"],
                "start": event["start"],
                "end": event["end"],
                "type": event.get("type", "event")
            }
            today_items.append(item)
            
            # Find next upcoming event
            if start_dt > now and next_item is None:
                next_item = item
                
        except (KeyError, ValueError):
            continue
    
    # Sort by start time
    today_items.sort(key=lambda x: x["start"])
    
    # If no future events, next_item is the last one
    if next_item is None and today_items:
        next_item = today_items[-1]
    
    return {
        "next_item": next_item,
        "today": today_items
    }


# ==================== NEW WEEKLY SCHEDULE SUMMARIES ====================

def generate_day_summary(day_name: str, events: List[Dict[str, Any]]) -> str:
    """
    Generate a natural language summary for a specific day.
    
    Args:
        day_name: Name of the day (e.g., "monday")
        events: List of events for that day
        
    Returns:
        Human-readable summary string
    """
    if not events:
        return f"You have no events scheduled for {day_name.capitalize()}."
    
    # Format events for the prompt
    formatted_items = []
    for event in events:
        try:
            start_dt = datetime.fromisoformat(event["start"])
            end_dt = datetime.fromisoformat(event["end"])
            
            start_human = start_dt.strftime("%H:%M")
            end_human = end_dt.strftime("%H:%M")
            name = event.get("name", "Unnamed event")
            
            formatted_items.append(f"{start_human}–{end_human}: {name}")
        except (KeyError, ValueError):
            continue
    
    if not formatted_items:
        return f"You have no valid events scheduled for {day_name.capitalize()}."
    
    formatted_items.sort()
    schedule_block = "\n".join(formatted_items)
    
    system_prompt = (
        "You are a concise, friendly personal assistant. "
        "Summarize the user's schedule for a specific day clearly and naturally. "
        "Convert 24-hour times to natural 12-hour phrases (like '10am', '4pm'). "
        "Keep it brief - 2-3 sentences maximum. This will be spoken aloud."
    )
    
    user_prompt = (
        f"Here is the user's schedule for {day_name.capitalize()}:\n\n"
        f"{schedule_block}\n\n"
        "Please summarize this schedule in natural language."
    )
    
    try:
        client = get_openai_client()
        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ]
        )
        return response.choices[0].message.content.strip()
    except Exception as e:
        print(f"[summary_generator] Error generating day summary: {e}")
        # Fallback to simple summary
        return f"On {day_name.capitalize()}, you have {len(events)} events scheduled."


def generate_week_summary(week_data: Dict[str, Dict[str, Any]]) -> str:
    """
    Generate a natural language summary of the entire week.
    
    Args:
        week_data: Dictionary mapping day names to their schedule data
                  (from schedule_manager.get_week_summary_data()["days"])
        
    Returns:
        Human-readable week overview string
    """
    # Build a summary of each day
    day_summaries = []
    total_events = 0
    
    for day in DAYS_OF_WEEK:
        day_info = week_data.get(day, {})
        event_count = day_info.get("event_count", 0)
        total_events += event_count
        
        if event_count > 0:
            events = day_info.get("events", [])
            event_names = [e.get("name", "event") for e in events[:3]]
            if len(events) > 3:
                event_names.append(f"and {len(events) - 3} more")
            day_summaries.append(f"{day.capitalize()}: {', '.join(event_names)}")
    
    if total_events == 0:
        return "Your week is completely free. No events scheduled."
    
    schedule_block = "\n".join(day_summaries) if day_summaries else "No events"
    
    system_prompt = (
        "You are a concise, friendly personal assistant. "
        "Give a brief overview of the user's week schedule. "
        "Highlight busy days and mention free days. "
        "Keep it brief - 3-4 sentences maximum. This will be spoken aloud."
    )
    
    user_prompt = (
        f"Here is the user's week overview (total {total_events} events):\n\n"
        f"{schedule_block}\n\n"
        "Please summarize this week in natural language."
    )
    
    try:
        client = get_openai_client()
        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ]
        )
        return response.choices[0].message.content.strip()
    except Exception as e:
        print(f"[summary_generator] Error generating week summary: {e}")
        return f"You have {total_events} events scheduled this week."


def generate_changes_summary(changes: Dict[str, Any]) -> str:
    """
    Generate a natural language summary of changes made to the schedule.
    Used for TTS feedback after modifications.
    
    Args:
        changes: Dictionary with:
            - added: List of (day, event_name) tuples
            - deleted: List of (day, event_name) tuples  
            - modified: List of (day, event_name) tuples
            - affected_days: List of day names that were changed
        
    Returns:
        Human-readable summary of changes for TTS
    """
    added = changes.get("added", [])
    deleted = changes.get("deleted", [])
    modified = changes.get("modified", [])
    
    if not added and not deleted and not modified:
        return "No changes were made to your schedule."
    
    parts = []
    
    # Summarize additions
    if added:
        if len(added) == 1:
            day, name = added[0]
            parts.append(f"Added {name} on {day.capitalize()}")
        else:
            add_summary = ", ".join([f"{name} on {day.capitalize()}" for day, name in added[:3]])
            if len(added) > 3:
                add_summary += f" and {len(added) - 3} more events"
            parts.append(f"Added {add_summary}")
    
    # Summarize deletions
    if deleted:
        if len(deleted) == 1:
            day, name = deleted[0]
            parts.append(f"removed {name} from {day.capitalize()}")
        else:
            del_summary = ", ".join([name for _, name in deleted[:3]])
            if len(deleted) > 3:
                del_summary += f" and {len(deleted) - 3} more"
            parts.append(f"removed {del_summary}")
    
    # Summarize modifications
    if modified:
        if len(modified) == 1:
            day, name = modified[0]
            parts.append(f"updated {name} on {day.capitalize()}")
        else:
            mod_summary = ", ".join([name for _, name in modified[:3]])
            parts.append(f"updated {mod_summary}")
    
    # Combine parts
    if len(parts) == 1:
        return parts[0] + "."
    elif len(parts) == 2:
        return f"{parts[0]} and {parts[1]}."
    else:
        return ", ".join(parts[:-1]) + f", and {parts[-1]}."


def generate_changes_summary_with_conflicts(changes: Dict[str, Any]) -> str:
    """
    Generate a natural language summary including conflict resolution info.
    Used for TTS feedback when events were automatically rescheduled.
    
    Args:
        changes: Dictionary with:
            - added: List of (day, event_name) tuples
            - deleted: List of (day, event_name) tuples  
            - modified: List of (day, event_name) tuples
            - rescheduled: List of (day, event_name, new_time) tuples
        
    Returns:
        Human-readable summary of changes for TTS
    """
    added = changes.get("added", [])
    deleted = changes.get("deleted", [])
    modified = changes.get("modified", [])
    rescheduled = changes.get("rescheduled", [])
    
    if not added and not deleted and not modified and not rescheduled:
        return "No changes were made to your schedule."
    
    parts = []
    
    # Summarize additions (non-rescheduled)
    if added:
        if len(added) == 1:
            day, name = added[0]
            parts.append(f"Added {name} on {day.capitalize()}")
        else:
            add_summary = ", ".join([f"{name} on {day.capitalize()}" for day, name in added[:3]])
            if len(added) > 3:
                add_summary += f" and {len(added) - 3} more events"
            parts.append(f"Added {add_summary}")
    
    # Summarize rescheduled events (due to conflicts)
    if rescheduled:
        for day, name, new_time in rescheduled:
            if new_time:
                parts.append(f"rescheduled {name} to {new_time} on {day.capitalize()} due to a conflict")
            else:
                parts.append(f"rescheduled {name} on {day.capitalize()} to avoid a conflict")
    
    # Summarize deletions
    if deleted:
        if len(deleted) == 1:
            day, name = deleted[0]
            parts.append(f"removed {name} from {day.capitalize()}")
        else:
            del_summary = ", ".join([name for _, name in deleted[:3]])
            if len(deleted) > 3:
                del_summary += f" and {len(deleted) - 3} more"
            parts.append(f"removed {del_summary}")
    
    # Summarize modifications
    if modified:
        if len(modified) == 1:
            day, name = modified[0]
            parts.append(f"updated {name} on {day.capitalize()}")
        else:
            mod_summary = ", ".join([name for _, name in modified[:3]])
            parts.append(f"updated {mod_summary}")
    
    # Combine parts
    if len(parts) == 1:
        return parts[0] + "."
    elif len(parts) == 2:
        return f"{parts[0]} and {parts[1]}."
    else:
        # Capitalize first part
        result = parts[0]
        for i, part in enumerate(parts[1:], 1):
            if i == len(parts) - 1:
                result += f", and {part}"
            else:
                result += f", {part}"
        return result + "."


def generate_clear_confirmation(scope: str, day_name: str = None) -> str:
    """
    Generate a confirmation message for clearing schedules.
    
    Args:
        scope: "day" or "week"
        day_name: Name of the day (required if scope is "day")
        
    Returns:
        Confirmation message for TTS
    """
    if scope == "week":
        return "I've cleared your entire week schedule. You're starting fresh."
    elif scope == "day" and day_name:
        return f"I've cleared all events from {day_name.capitalize()}."
    else:
        return "Schedule cleared."


def generate_query_response(day_name: str, events: List[Dict[str, Any]], is_today: bool = False) -> str:
    """
    Generate a response for schedule queries.
    
    Args:
        day_name: Name of the day being queried
        events: Events for that day
        is_today: Whether this is today's schedule
        
    Returns:
        Natural language response for TTS
    """
    if not events:
        if is_today:
            return "You have no events scheduled for today. Your day is free!"
        return f"You have no events scheduled for {day_name.capitalize()}."
    
    # Generate detailed summary
    return generate_day_summary(day_name, events)
